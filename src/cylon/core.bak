;; -*- clojure -*-
;; Copyright Â© 2014, JUXT LTD. All Rights Reserved.
;;
;; Licensed under the Apache License, Version 2.0 (the "License");
;; you may not use this file except in compliance with the License.
;; You may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.

(ns cylon.core
  (:require
   [clojure.java.io :as io]

   #_[clojure.pprint :refer (pprint)]
   #_[bidi.bidi :as bidi :refer (path-for resolve-handler unresolve-handler ->WrapMiddleware Matched)]
   #_[modular.ring :refer (ring-handler RingHandler)]
   #_[modular.bidi :as modbidi :refer (WebService ring-handler-map routes uri-context)]
   #_[schema.core :as s]
   #_[ring.middleware.cookies :refer (wrap-cookies cookies-request)]
   #_[ring.middleware.params :refer (wrap-params)]
   #_[hiccup.core :refer (html)]
   #_[com.stuartsierra.component :as component])
  #_(:import
   java.security.SecureRandom
   javax.crypto.SecretKeyFactory
   javax.crypto.spec.PBEKeySpec
   (javax.xml.bind DatatypeConverter)))

;; ----------------



;; This implementation of a user domain provides a password storage
;; facility based on PASSWORD_HASH_ALGO and a pluggable store for
;; persistence

;; -------



;; Certain objects can provide protection for routes
#_(defprotocol BidiRoutesProtector
  (protect-bidi-routes [_ routes]))



;; bidi (https://github.com/juxt/bidi) is required for the functions below

#_(defn make-authentication-wrapper
  "Currently bidi's WrapMiddleware only allows middleware with a single
  handler argument. This function provides an adapter."
  [authenticator failure-handler]
  (fn [h]
    (wrap-authentication h authenticator failure-handler)))

#_(defrecord ProtectMatched [routes opts]
  bidi/Matched
  (resolve-handler [this m]
    (let [r (resolve-handler routes m)]
      (if (:handler r)
        (update-in r [:handler]
                   (comp wrap-cookies
                         (make-authentication-wrapper
                          (:http-request-authenticator opts)
                          (:failed-authentication-handler opts))))
        r)))
  (unresolve-handler [this m]
    (unresolve-handler routes m)))

#_(defn add-bidi-protection-wrapper [routes & {:as opts}]
  ["" (->ProtectMatched
       [routes]
       (s/validate
        {:http-request-authenticator (s/protocol HttpRequestAuthenticator)
         (s/optional-key :failed-authentication-handler) (s/protocol FailedAuthenticationHandler)}
        opts))])

#_(defrecord BidiFailedAuthenticationRedirect [h]
  FailedAuthenticationHandler
  (failed-authentication [_ req]
    {:status 302
     :headers {"Location" (path-for (:modular.bidi/routes req) h)}
     :body "Not authenticated\n"
     :cookies {"requested-uri" (:uri req)}}))

#_(defrecord MapBackedUserRegistry [m]
  UserAuthenticator
  (authenticate-user [_ user password]
    ((set (seq m)) [user password])))

#_(defn new-map-backed-user-registry [m]
  (->MapBackedUserRegistry m))


;; A request authoriser that uses HTTP basic auth





;; A request authenticator that uses cookie-based sessions






;; Since this module is dependent on bidi, let's provide some sample
;; bidi routes that can be used as-is or to demonstrate.









;; Now that we have a protection system, we want the ability to create
;; bidi routes components that can be protected by simply declaring a dependency upon the protection system component.
;; However, these will probably be deprecated soon and replaced with a more general method of restricting handlers to roles

#_(defrecord ProtectedBidiRoutes [routes uri-context]
  component/Lifecycle
  (start [this]
    (let [protection (get-in this [:protection-system])
          routes (cond-> routes
                         (fn? routes) (apply [this])
                         protection ((partial protect-bidi-routes protection)))]
      (assoc this :routes routes)))
  (stop [this] this)

  WebService
  (ring-handler-map [this] {})
  (routes [this] (:routes this))
  (uri-context [this] uri-context))

#_(defn new-optionally-protected-bidi-routes
  "Create a set of protected routes. Routes can a bidi route structure, or
  a function that takes the component and returns a bidi route
  structure."
  [routes & {:as opts}]
  (let [{:keys [context]}
        (->> (merge {:context ""} opts)
             (s/validate {:context s/Str}))]
    (->ProtectedBidiRoutes routes context)))

#_(defn new-protected-bidi-routes
  "Like new-optionally-protected-bidi-routes above, but the absence of
  a :protection-system dependency will cause an error."
  [routes & {:as opts}]
  (component/using
   (apply new-optionally-protected-bidi-routes routes (apply concat (seq opts)))
   [:protection-system]))

;; Authorization

;; Bidi handlers can be subject to access restrictions. We restrict at
;; the level of the handler rather than the route, because it's the
;; handler that determines what kind of data is being returned. It is
;; data itself that is sensitive to access, not the URIs.

(defprotocol HandlerAuthorizer
  (allowed-handler? [_ req]))

;; Ring middleware
(defn restrict-to-authorized [h handler-authorizer]
  (fn [req]
    (if (allowed-handler? handler-authorizer req)
      (h req)
      (throw (ex-info "Unauthorized" (merge
                                      (select-keys req [::username ::user-roles])
                                      {:handler-authorizer handler-authorizer}))))))

;; This is intended to wrap an individual Ring handler. By using a
;; record, rather than a function, we can satisfy the HandlerAuthorizer
;; protocol which can indicate whether this handler would be authorized
;; given the current request without asking it to handle the request.

(defrecord RestrictedHandler [delegate-handler authorized?]
  HandlerAuthorizer
  (allowed-handler? [this req]
    (cond
     ;;(satisfies? RoleQualifier authorized?) (user-in-role? (::user-roles req) (::username req) authorized?)
     (fn? authorized?) (authorized? req)
     :otherwise (throw (ex-info ("Unsupported type of authorizer: %s" (type authorized?)) {:authorized? authorized?}))))

  clojure.lang.IFn
  (invoke [this req]
    (if (allowed-handler? this req)
      (delegate-handler req)
      ;; If you don't want this default, call allowed-handler? first!
      {:status 401 :body "Unauthorized handler"})))

(extend-protocol HandlerAuthorizer
  ;; 'Normal' handlers are not wrapped in a record, but must be able to
  ;; give an answer if given as an argument to allowed-handler? above.
  clojure.lang.Fn
  (allowed-handler? [this req] true)
  nil
  (allowed-handler? [this req] nil))

(defn restrict-handler
  "Restrict the given route. If authorized? is a predicate function, it
  must take a single argument (the Ring request). Otherwise, if
  authorized? is a keyword, then it represents a role that much match
  the user. If it is a set of roles, then the user must match one of
  those roles. If it is a vector of roles, the user must match all."
  [matched authorized?]
  (->RestrictedHandler matched authorized?))

(defn restrict-handler-map
  "Restrict all the values in the given map according to the given
  authorization."
  [m authorized?]
  (reduce-kv (fn [acc k v] (assoc acc k (->RestrictedHandler v authorized?))) {} m))
